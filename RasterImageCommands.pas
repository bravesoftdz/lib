unit RasterImageCommands;

interface

uses classes,command_class_lib,Image_on_demand,pngImageAdvanced,graphics,types;

type

TRasterImageDocumentCommand = class (TAbstractTreeCommand)
  public
    function GetDoc: TRasterImageDocument;
  end;
TPatchImageCommand = class (TRasterImageDocumentCommand)
//базовая команда при работе с растровыми изображениями
//GetBounds выставляет предварительные размеры прямоугольника, где произойдет действие
//и при вызове Execute картинка из него будет сохранена в fDiff, и вызван internalExecute
//в потомках описываем internalExecute - как изменить изображение
//он может в числе прочего поменять формат всего изображения.
//при этом для каждой измененной точки внутри прямоуг. вызываем PointChanged, тем самым
//находим минимально необх. прямоугольник, который нужен для undo.
//далее, Top/Left принимают окончательное значение.
//наконец, вызывается UndoPrediction, который пытается, располагая только результирующей
//картинкой и свойствами команды, которые сохраняются в файл (не считая fDiff), восстановить
//(предсказать) исходное изображение. Если это реализовано, то из fDiff будет вычтен fPredictor.
//UndoPrediction имеет право узнать ColorMode и BitDepth из fDiff.

//при исполнении Undo первым делом запускается UndoPrediction, который дает ровно то же
//предсказанное изображение, что и раньше. Его мы прибавляем к загруженному fDiff.
//если формат изображения в документе поменялся и fDiff не занимает всю его область,
//то мы приводим его к старому формату, за исключением, возможно, измененной области
//наконец, мы "вклеиваем" на место fDiff.
  protected
    fDiff: TExtendedPngObject;
    fPredictor: TExtendedPngObject;
    fRect,fUpdateRect: TRect; //расположение заплатки и вычисление мин. необх.
    fImageFormatChanged: Boolean;
    fOldBitDepth,fOldColorType: Byte;
    procedure GetBounds; virtual; abstract;//инициализировать fLeft,fTop,fRight,fBottom
    procedure PointChanged(const x,y: Integer); //вызывается из потомка,
    // если в (x,y) произошли изменения, нужна для нахождения минимального прямоуг.
    function UndoPrediction: Boolean; virtual;  //false означает
    //что мы ничего не можем предсказать, поэтому оставляем картинку как есть
    function InternalExecute: Boolean; virtual; abstract; //false означает,
    //что применение команды ничего не изменило и ее стоит изъять из дерева
  public
    constructor Create(aOwner: TComponent); overload; override;
    destructor Destroy; override;
    function Execute: Boolean; override;
    function Undo: Boolean; override;
  published
    property diff: TExtendedPngObject read fDiff write fDiff;
    property Left: Integer read fRect.Left write fRect.Left;
    property Top: Integer read fRect.Top write fRect.Top;
    property BitDepth: Byte read fOldBitDepth write fOldBitDepth stored fImageFormatChanged;
    property ColorType: Byte read fOldColorType write fOldColorType stored fImageFormatChanged;
  end;

TWordPoint=record
  case Integer of
    0: (X,Y: Word);
    1: (AsPointer: Pointer);
end;

TBrushCommand = class (TPatchImageCommand)
  private
    fBrushColor: TColor;
    fBrushSize: Word;
    fBrushShape: TBrushShape;
    fPoints: TList;
    fColorExistsInPalette: Boolean; //есть ли готовый индекс для цвета, которым
    //закрашиваем
    fNeedToChangeBitDepth: Boolean; //и палитра набита под завязку, придется бит/пиксель повышать
    fNewBitDepth: Byte;
    fNewColorMode: Byte;
    fColorIndex: Cardinal;  //от 1 бита до 24 бит, по обстоятельствам
//    fRect: TRect;
    fPointsReduced: Boolean;  //отметка, что не нужно шерстить набор точек по-новой
    procedure ReadPointsAsText(reader: TReader);
    procedure WritePointsAsText(writer: TWriter);
    procedure WritePoints(stream: TStream);
    procedure ReadPoints(stream: TStream);
    procedure ReducePoints;
    procedure FigureAboutColorsAndBitdepth;
  protected
    procedure DefineProperties(filer: TFiler); override;
    procedure GetBounds; override;  //заполняет fRect
  public
    constructor Create(aOwner: TComponent); override;
    //поскольку он должен работать с документом (только для чтения) еще до
    //исполнения DispatchCommand, передаём ему заблаговременно
    destructor Destroy; override; //TList надо освободить
    function Draw(aX,aY: Word): boolean;  //один мазок кисти
    //если хоть как-то меняется, заносим в fXPoints/fYPoints
    function InternalExecute: Boolean; override;
  published
    property BrushColor: TColor read fBrushColor write fBrushColor;
    property BrushSize: Word read fBrushSize write fBrushSize;
    property BrushShape: TBrushShape read fBrushShape write fBrushShape;
  end;
implementation

uses pngImage,gamma_function,sysUtils,simple_parser_lib,math;

(*
      TRasterImageDocumentCommand
                                      *)
function TRasterImageDocumentCommand.GetDoc: TRasterImageDocument;
begin
  Result:=FindOwner as TRasterImageDocument;
end;

(*
      TPatchImageCommand
                            *)
constructor TPatchImageCommand.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);
  fDiff:=TExtendedPngObject.Create; //будет сохраняться в файл
end;

destructor TPatchImageCommand.Destroy;
begin
  fDiff.Free;
  inherited Destroy;
end;

procedure TPatchImageCommand.PointChanged(const X,Y: Integer);
begin
  fUpdateRect.Left:=min(fUpdateRect.Left,X);
  fUpdateRect.Right:=max(fUpdateRect.Right,X);
  fUpdateRect.Top:=min(fUpdateRect.Top,Y);
  fUpdateRect.Bottom:=max(fUpdateRect.Bottom,Y);
end;

function TPatchImageCommand.Execute: Boolean;
var doc: TRasterImageDocument;
  btmp,tmp: TExtendedPNGObject;
  src,dest: TPngObjectIterator;
begin
  getBounds;  //инициализирует fRect
  doc:=GetDoc;
  btmp:=doc.Btmp;
  fOldBitDepth:=btmp.Header.BitDepth;
  fOldColorType:=btmp.Header.ColorType;
  //обозначили заплатку
  fDiff.Free;
  fDiff:=TExtendedPNGObject.CreateBlank(Btmp.Header.ColorType,
    Btmp.Header.BitDepth,fRect.Right-fRect.Left,fRect.Bottom-fRect.Top);

//  fDiff.Canvas.CopyRect(Rect(0,0,fDiff.Width,fDiff.Height),Doc.Btmp.Canvas,
//    Rect(fLeft,fTop,fRight,fBottom));
  //copyRect вроде быстрый, но не thread-safe (а мы хотим быть thread-safe, не знаю зачем)
  //и кто его знает, что он там делает, этот stretchBlt
  //так надежнее:
  src:=btmp.CreateIteratorForCropped(fRect);
  dest:=fDiff.CreateIterator;
  while not src.isEOF do
    dest.WriteNextPixel(src.ReadNextPixel);
  dest.Free;
  src.Free;
  //можно еще ввести какой-нибудь пакетный режим, чтоб ещё быстрее
  //в fUpdateRect загоняем фактически -Inf и +Inf
  fUpdateRect.Left:=fRect.Right;
  fUpdateRect.Right:=fRect.Left-1;
  fUpdateRect.Top:=fRect.Bottom;
  fUpdateRect.Bottom:=fRect.Top-1;
  //храним в fDiff копию того фрагмента, который начнем мучать
  Result:=InternalExecute;
  if Result then begin
    inc(fUpdateRect.Right);
    inc(fUpdateRect.Bottom);
  //после InternalExecute еще могли поменяться границы
    if (fRect.Left<>fUpdateRect.Left) or (fRect.Right<>fUpdateRect.Right)
      or (fRect.Top<>fUpdateRect.Top) or (fRect.Bottom<>fUpdateRect.Bottom) then
    begin
      tmp:=fDiff;
      fDiff:=TExtendedPNGObject.CreateBlank(tmp.Header.ColorType,
        tmp.Header.BitDepth,fUpdateRect.Right-fUpdateRect.Left,fUpdateRect.Bottom-fUpdateRect.Top);
      src:=tmp.CreateIteratorForCropped(Rect(fUpdateRect.Left-fRect.Left,fUpdateRect.Top-fRect.Top,
        fUpdateRect.Right-fRect.Left,fUpdateRect.Bottom-fRect.Top));
      dest:=fDiff.CreateIterator;
      while not src.isEOF do
        dest.WriteNextPixel(src.ReadNextPixel);
      dest.Free;
      src.Free;
      tmp.Free;
      fRect:=fUpdateRect;
    end;
    //fPredictor должен иметь те же параметры ColorType,BitDepth, Width, Height
    fPredictor:=TExtendedPngObject.CreateBlank(fDiff.Header.ColorType,
      fDiff.Header.BitDepth,fDiff.Width,fDiff.Height);
    if UndoPrediction then begin
      //нарисует на Predictor исх. картинку исходя из того, что он
      //может знать по конечному результату
      //сейчас "скользкая" часть - вычесть одну картинку из другой
      //RGB24 - надо вычитать по каждому цвету
      //Grayscale - значение целиком
      //Palette - значение целиком, адекватность должен обеспечить UndoPrediction
      src:=fPredictor.CreateIterator;
      dest:=fDiff.CreateIterator;
      //that's how I sub.
      while not src.isEOF do
        dest.WriteNextSubpixel((dest.PeekNextSubpixel-src.ReadNextSubpixel) and 255);
      //ох незадача, он же при "умном сохранении" может ужаться в плане цветности, тогда
      //мы по нему не восстановим ориг. формат изобр.
      //поэтому добавили свойства BitDepth и ColorType
      dest.Free;
      src.Free;
    end;
    fPredictor.Free;
    //а на нет и суда нет
    //наконец, сообщим документу, какую область мы изменили
    doc.AddToChangeRect(fRect);
  end;
  //в противном случае команда вот-вот будет удалена, нет нужды освобождать
  //память впереди паровоза
end;

function TPatchImageCommand.Undo: Boolean;
var doc: TRasterImageDocument;
    src,dest: TPngObjectIterator;
    tmp: TExtendedPngObject;
begin
  //формируем прямоугольник, на котором произошли изменения. Его верхний угол хранится в Top/Left
  //он по сути на месте, а по размерам заплатки восст. нижний правый угол
  fRect.Bottom:=fRect.Top+fDiff.Height;
  fRect.Right:=fRect.Left+fDiff.Width;
  doc:=GetDoc;
  doc.AddToChangeRect(fRect); //можно сразу сообщить, мы уже все знаем.
  if ColorType=0 then ColorType:=doc.Btmp.Header.ColorType;//если формат не поменялся,
  if BitDepth=0 then BitDepth:=doc.Btmp.Header.BitDepth;//мы его и не сохраняем!
  //возможно, формат fDiff успел поменяться после сохранения, для уменьшения размера
  if (fDiff.Header.BitDepth<>BitDepth) or (fDiff.Header.ColorType<>ColorType) then begin
    tmp:=fDiff.GetInOtherFormat(ColorType,BitDepth);
    fDiff.Free;
    fDiff:=tmp;
  end;
  fPredictor:=TExtendedPngObject.CreateBlank(ColorType,BitDepth,fDiff.Width,fDiff.Height);
  if UndoPrediction then begin
    //в прошлый раз вычитали fPredictor, теперь прибавим назад.
    src:=fPredictor.CreateIterator;
    dest:=fDiff.CreateIterator;
    //that's how I add.
    while not src.isEOF do
      dest.WriteNextSubpixel((dest.PeekNextSubpixel+src.ReadNextSubpixel) and 255);
    dest.Free;
    src.Free;
  end;
  fPredictor.Free;
  //а на нет и суда нет
  //осталось вправить картинку на место
  if (doc.Btmp.Header.ColorType<>ColorType) or (doc.Btmp.Header.BitDepth<>BitDepth) then begin
    tmp:=doc.Btmp.GetInOtherFormat(ColorType,BitDepth);
    doc.Btmp.Free;
    doc.Btmp:=tmp;
  end;

  src:=fDiff.CreateIterator;
  dest:=doc.Btmp.CreateIteratorForCropped(fRect);
  while not src.isEOF do
    dest.WriteNextPixel(src.ReadNextPixel);
  dest.Free;
  src.Free;
  Result:=true;
end;

function TPatchImageCommand.UndoPrediction: Boolean;
begin
  Result:=false;
end;

(*
    TBrushCommand
                    *)
function BrushColorIsMonochrome(color: TColor; out index: Cardinal): boolean;
var rgbcol: RGBColor absolute color;
begin
  Result:=(rgbcol.R=rgbcol.G) and (rgbcol.G=rgbcol.B);
  if Result then index:=rgbcol.R;
end;

function BrushColorInMonochromePalette(color: TColor;aBitDepth: Byte; out index: Cardinal): boolean;
var rgbcol: RGBColor absolute color;
    maxColorVal: Word;
begin
  maxColorVal:=(1 shl aBitDepth)-1;
  Result:= BrushColorIsMonochrome(color,index) and
    (((index * maxColorVal div 255) * 255) div maxColorVal = index);
  if Result then index:=(index*maxColorVal) div 255; //к примеру
end;

constructor TBrushCommand.Create(aOwner: TComponent);
begin
  inherited Create(aOwner);
  fPoints:=TList.Create;
end;

procedure TBrushCommand.FigureAboutColorsAndBitdepth;
var btmp: TExtendedPNGObject;
  fActualCount: Integer;
  p: Integer;
  fFutureOwner: TRasterImageDocument;
  //можно было бы обойтись и без него
begin
//философия такая: если есть возможность обойтись без переформатирования картинки,
//надо за неё цепляться
//но если все равно повышать количество бит на пиксель, то не жадничать, а сразу
//делать побольше, с запасом.
  fFutureOwner:=GetDoc;
  btmp:=fFutureOwner.Btmp;
  case Btmp.Header.ColorType of
    COLOR_RGB: begin
      fColorExistsInPalette:=true;
      fColorIndex:=TColorToRGBTriple(fBrushColor);
      //ничего менять не надо!
      end;
    COLOR_GRAYSCALE: begin
      fColorExistsInPalette:=
        BrushColorInMonochromePalette(fBrushColor,Btmp.Header.BitDepth,fColorIndex);
      if not fColorExistsInPalette then begin
        //очень не хочется изменять биты/пиксель
        fNeedToChangeBitDepth:=not Btmp.IsColorNumberLessThen(1 shl Btmp.Header.BitDepth, fActualCount);
        if fNeedToChangeBitDepth then begin
          fNewBitDepth:=8;
          if BrushColorIsMonochrome(fBrushColor,fColorIndex) then
            fNewColorMode:=COLOR_GRAYSCALE
          else
            fNewColorMode:=COLOR_RGB;
        end
        else begin
          fNewColorMode:=COLOR_PALETTE;
          fColorIndex:=fActualCount;
        end;
      end;
    end;
    COLOR_PALETTE: begin
      //нужно определить, если ли наш цвет в палитре
      p:=btmp.GetColorIndex(fBrushColor);
      fColorExistsInPalette:=(p>=0);
      if fColorExistsInPalette then
        fColorIndex:=p
      else begin
        //вот ведь незадача
        fNeedToChangeBitDepth:=not Btmp.IsColorNumberLessThen(1 shl Btmp.Header.BitDepth, fActualCount);
        if fNeedToChangeBitDepth then begin
          fNewBitDepth:=8;
          if fActualCount>=256 then
            fNewColorMode:=COLOR_RGB
          else
            fNewColorMode:=COLOR_PALETTE;
        end
        else begin
          fNewColorMode:=COLOR_PALETTE;
          fColorIndex:=fActualCount;
        end;
      end;
    end;
    else
      Raise Exception.Create('sorry, alpha channel support under construction');
  end;
end;

destructor TBrushCommand.Destroy;
begin
  fPoints.Free;
  inherited Destroy;
end;

procedure TBrushCommand.GetBounds;
var ourRect: TRect;
    i: Integer;
    p: TWordPoint;
begin
  fBrushColor:=GetDoc.PrimaryColor;
  fBrushSize:=GetDoc.BrushSize;
  fBrushShape:=GetDoc.BrushShape;
  fRect:=Rect(0,0,0,0);
  for i:=0 to fPoints.Count-1 do begin
    p.AsPointer:=fPoints[i];
    ourRect:=Rect(p.X-fBrushSize div 2,p.Y-fBrushSize div 2,p.X+fBrushSize div 2, p.Y+fBrushSize div 2);
    CoverRect(fRect,ourRect);
  end;
end;

function TBrushCommand.Draw(aX,aY: Word): Boolean;
var point: TWordPoint;
begin
  point.X:=aX;
  point.Y:=aY;
  Result:=(fPoints.IndexOf(point.AsPointer)=-1);
  if Result then begin
    fPoints.Add(point.AsPointer);
  end;
end;

procedure TBrushCommand.DefineProperties(filer: TFiler);
begin
//  filer.DefineBinaryProperty('points',ReadPoints,WritePoints,true);
  filer.DefineProperty('points',ReadPointsAsText,WritePointsAsText,true);
end;

procedure TBrushCommand.WritePoints(stream: TStream);
begin
  ReducePoints;

end;

procedure TBrushCommand.ReadPoints(stream: TStream);
begin

end;

procedure TBrushCommand.WritePointsAsText(writer: TWriter);
var i: Integer;
    cur: TWordPoint;
begin
  ReducePoints;
  writer.WriteListBegin;
  for i:=0 to fPoints.Count-1 do begin
    cur:=TWordPoint(fPoints[i]);
    writer.WriteString('('+IntToStr(cur.X)+';'+IntToStr(cur.Y)+')');
  end;
  writer.WriteListEnd;
end;

procedure TBrushCommand.ReadPointsAsText(reader: TReader);
var p: TSimpleParser;
    cur: TWordPoint;
begin
  reader.ReadListBegin;
  p:=TSimpleParser.Create;
  fPoints.Clear;
  while not reader.EndOfList do begin
    p.AssignString(reader.ReadString);
    p.getChar; //'('
    cur.X:=p.getInt;
    //; - это delimiter, его читать не надо. 
    cur.Y:=p.getInt;
    fPoints.Add(cur.AsPointer);
  end;
  p.Free;
  reader.ReadListEnd;
end;


procedure TBrushCommand.ReducePoints;
begin
  if fPointsReduced then Exit;
  //надеемся малость подсократить количество точек
  //а пока ничего не делаем
  fPointsReduced:=true;
end;

function TBrushCommand.InternalExecute: Boolean;
var btmp: TExtendedPngObject;
    dest: TPngObjectIterator;
    i: Integer;
    point: TWordPoint;
    sizesq: Integer;
begin
  Result:=fPoints.Count>0;
  if not Result then exit;
  //пока все выполняем в одной TBrushCommand,
  //потом, когда новую команду будем делать, сообразим,
  //как общие куски вынести в предка
  FigureAboutColorsAndBitdepth;  
  ReducePoints;
  btmp:=GetDoc.Btmp;
  //бекап есть, теперь, если надо, переделываем изображение
  if not fColorExistsInPalette then begin
    if fNeedToChangeBitDepth then begin
      //коренное переформатирование
      Btmp:=btmp.GetInOtherFormat(fNewColorMode,fNewBitDepth);
      GetDoc.Btmp.Free;
      GetDoc.Btmp:=Btmp;
    end
    else begin
      raise Exception.Create('convert to palette: dangerous procedure, may corrupt data');
      Btmp.ConvertToPalette;
    end;
    if (fNewColorMode=COLOR_PALETTE) and (Btmp.GetColorIndex(fBrushColor)=-1) then
      fColorIndex:=Btmp.AddToPalette(fBrushColor);
  end;
  //работаем кистью
  for i:=0 to fPoints.Count-1 do begin
    point:=TWordPoint(fPoints[i]);
    dest:=btmp.CreateIteratorForCropped(Rect(point.X-fBrushSize div 2,point.Y-fBrushSize div 2,
      point.X + fBrushSize div 2, point.Y+fBrushSize div 2));
    if fBrushShape=bsSquare then
      while not dest.isEOF do begin
        if dest.PeekNextPixel<>fColorIndex then
          PointChanged(dest.CurColumn,dest.CurLine);
        dest.WriteNextPixel(fColorIndex);
      end
    else begin
      sizesq:=Sqr(fBrushSize div 2);
      while not dest.isEOF do
       if (sqr(dest.CurLine-point.Y)+sqr(dest.CurColumn-point.X)<sizesq)
         and (dest.PeekNextPixel<>fColorIndex) then begin
          dest.WriteNextPixel(fColorIndex);
          PointChanged(dest.CurColumn,dest.CurLine);
         end
       else
        dest.WriteNextPixel(dest.PeekNextPixel);
    end;
    dest.Free;
  end;
end;


initialization
  RegisterClasses([TBrushCommand]);

end.
